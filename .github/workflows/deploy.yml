name: Backend CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - 'server/**'
      - 'infra/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches: [main]
    paths:
      - 'server/**'
      - 'infra/**'

env:
  NODE_VERSION: '22'

jobs:
  ci:
    name: CI - 代码质量检查
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: ky_pokemon_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: "postgresql://postgres:postgres@localhost:5432/ky_pokemon_test"

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: server/package.json

      - name: 安装依赖 (Root)
        run: npm install

      - name: 安装依赖 (Server)
        working-directory: server
        run: npm install

      - name: 生成 Prisma Client
        working-directory: server
        run: npx prisma generate

      - name: 构建后端
        working-directory: server
        run: npm run build

      - name: 创建 Shadow 数据库
        run: PGPASSWORD=postgres psql -h localhost -U postgres -c "CREATE DATABASE shadow_db;"

      - name: 检查 Schema 与迁移同步
        working-directory: server
        run: |
          npx prisma migrate diff \
            --from-migrations ./prisma/migrations \
            --to-schema-datamodel ./prisma/schema.prisma \
            --shadow-database-url "postgresql://postgres:postgres@localhost:5432/shadow_db" \
            --exit-code || {
              echo "::error::Schema 与迁移不同步！请运行 prisma migrate dev 生成新的迁移文件。"
              exit 1
            }

      - name: 上传构建产物
        uses: actions/upload-artifact@v4
        with:
          name: server-dist
          path: server/dist
          retention-days: 1

  deploy:
    name: CD - 部署到阿里云 FC
    needs: ci
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && vars.ENABLE_DEPLOY == 'true'

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 下载构建产物
        uses: actions/download-artifact@v4
        with:
          name: server-dist
          path: server/dist

      - name: 安装依赖 (用于获取 Prisma 引擎)
        working-directory: server
        run: npm install

      - name: 生成 Prisma Client
        working-directory: server
        run: npx prisma generate

      - name: 创建 FC 部署包
        run: |
          set -e
          rm -rf fc-deploy
          mkdir -p fc-deploy
          
          # 1. 复制构建产物和配置
          cp -r server/dist fc-deploy/
          cp server/package.json fc-deploy/
          mkdir -p fc-deploy/prisma
          cp server/prisma/schema.prisma fc-deploy/prisma/
          cp -r server/prisma/migrations fc-deploy/prisma/
          
          # 2. 进入部署目录进行依赖安装和生成
          cd fc-deploy
          
          # 安装生产依赖 (会自动包含 prisma engines 如果它是 dependency)
          # 注意：我们需要确保 prisma CLI 也在，或者使用 npx (但 npx 需要 devDependencies)
          # 为了稳妥，我们临时安装 prisma CLI，生成完再移除，或者直接把 prisma 放入 dependencies (虽然不推荐但对 FC 方便)
          # 更好的方式：使用 CI 环境的 prisma CLI 来生成到当前目录
          
          npm install --production
          
          # 3. 显式生成 Prisma Client 到当前 node_modules
          # 使用根目录安装的 prisma CLI，但指定 schema 路径
          echo "Generating Prisma Client..."
          ../server/node_modules/.bin/prisma generate --schema=./prisma/schema.prisma
          
          # 4. 验证生成结果
          echo "=== Verifying .prisma directory ==="
          ls -la node_modules/.prisma/client || echo "Error: .prisma/client not found!"
          
          # 5. 清理 (Prisma CLI 很大，尽量不打包进去，但 Engine 必须留着)
          # 注意：prisma generate 生成的 client 依赖于 @prisma/client 和底层的 engine
          # 我们不应该删除 node_modules/@prisma
          
          echo "=== Final node_modules size ==="
          du -sh node_modules/
          
          cd ..

      - name: 安装 Serverless Devs
        run: npm install -g @serverless-devs/s

      - name: 配置阿里云凭证
        run: |
          s config add \
            --AccountID ${{ secrets.ALIYUN_ACCOUNT_ID }} \
            --AccessKeyID ${{ secrets.ALIYUN_ACCESS_KEY_ID }} \
            --AccessKeySecret ${{ secrets.ALIYUN_ACCESS_KEY_SECRET }} \
            -a default

      - name: 部署到 FC
        id: deploy
        working-directory: infra
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          MIGRATION_TOKEN: ${{ secrets.MIGRATION_TOKEN }}
          VPC_ID: ${{ secrets.VPC_ID }}
          VSWITCH_ID: ${{ secrets.VSWITCH_ID }}
          SECURITY_GROUP_ID: ${{ secrets.SECURITY_GROUP_ID }}
        run: |
          s deploy -t s.yaml -y --use-local
          
          # 获取 FC URL
          INFO_JSON=$(s info -t s.yaml --output json 2>/dev/null)
          FC_URL=$(echo "$INFO_JSON" | node -e "
            const chunks = [];
            process.stdin.on('data', c => chunks.push(c));
            process.stdin.on('end', () => {
              try {
                const text = chunks.join('');
                const start = text.indexOf('{');
                const end = text.lastIndexOf('}');
                if (start === -1 || end === -1) { console.log(''); process.exit(0); }
                const json = JSON.parse(text.slice(start, end + 1));
                const url = json?.url?.system_url || json?.system_url || '';
                console.log(url);
              } catch { console.log(''); }
            });
          ")
          echo "FC_URL=${FC_URL}" >> $GITHUB_OUTPUT
          echo "部署完成，函数 URL: ${FC_URL}"

      - name: 更新 GitHub Variable (VITE_API_URL)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          FC_URL: ${{ steps.deploy.outputs.FC_URL }}
        run: |
          # 尝试更新 repository variable (需要权限)
          echo "尝试自动更新 VITE_API_URL 为: ${FC_URL}/api"
          gh variable set VITE_API_URL --body "${FC_URL}/api" || echo "Warning: 无法自动更新 VITE_API_URL，请手动设置。"

      - name: 等待服务就绪
        run: sleep 10

      - name: 执行数据库迁移
        env:
          FC_URL: ${{ steps.deploy.outputs.FC_URL }}
          MIGRATION_TOKEN: ${{ secrets.MIGRATION_TOKEN }}
        run: |
           echo "Triggering database migration on ${FC_URL}..."
           
           RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${FC_URL}/api/internal/db-migrate" \
             -H "x-migration-token: ${MIGRATION_TOKEN}" \
             -H "Content-Type: application/json" \
             --max-time 60)
           
           HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
           BODY=$(echo "$RESPONSE" | sed '$d')
           
           echo "Response: $BODY"
           
           if [ "$HTTP_CODE" != "200" ]; then
             echo "::error::Migration failed with status $HTTP_CODE"
             exit 1
           fi

      - name: 执行数据库种子 (Seed)
        env:
          FC_URL: ${{ steps.deploy.outputs.FC_URL }}
          MIGRATION_TOKEN: ${{ secrets.MIGRATION_TOKEN }}
        run: |
           echo "Triggering database seeding..."
           
           RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${FC_URL}/api/internal/db-seed" \
             -H "x-migration-token: ${MIGRATION_TOKEN}" \
             -H "Content-Type: application/json" \
             --max-time 60)
           
           HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
           BODY=$(echo "$RESPONSE" | sed '$d')
           
           echo "Response: $BODY"
           
           if [ "$HTTP_CODE" != "200" ]; then
             echo "::warning::Seeding failed with status $HTTP_CODE. Continuing as it might be non-critical."
           fi
